## Synthesis Loop

The **loop.py** script synthesizes hardware logic for MXInt4 multiplication. It iteratively adds input-output examples as constraints and uses the CVC5 solver to find a program that satisfies them. If the solver times out on a new constraint, that constraint is skipped. The final synthesized program is saved for evaluation.

## Evaluation

The file **evaluate.ipynb** compares the SMT-LIB multiplication code generated by SyGus to the ground truth values on randomly generated examples, and displays some metrics.

## Grammars (TODO)



## Constraints (TODO)
 
#### Constraint Seclection


#### Loosening the Constraints

## Results

The most succesfull candidate for calculating the mantissa  of multiplication (so far) is
```lisp
(define-fun mult_mxint_mant ((m1 (_ BitVec 4)) (e1 (_ BitVec 4)) (m2 (_ BitVec 4)) (e2 (_ BitVec 4))) (_ BitVec 4)
  (let ((m2_ext ((_ sign_extend 4) m2)))
    (let ((product_ext (bvmul ((_ sign_extend 4) m1) m2_ext)))
      ((_ extract 3 0)
        (ite (bvslt m2_ext #b00000000)
             (bvashr product_ext #b00000011)
             (bvashr product_ext #b00000010))))))
```

The following results can be reproduced using **evaluate.ipynb**.

#### Mantissa-Level Performance


| Metric | Value |
| :--- | :--- |
| **Total Test Cases** | 1000 |
| **Exact Matches** | 61.10% |
| **Mean Absolute Error** | 2.3610 |
| **Median Absolute Error**| 0.0 |
| **Max Absolute Error** | 12 |

#### Dequantized Float-Level Performance


| Metric | Value |
| :--- | :--- |
| **Total Test Cases** | 1000 |
| **Mean Absolute Error** | 2.5021 |
| **Median Absolute Error** | 0.0 |
| **Percentage within 0.1 error** | 62.00% |

## Experiments with genetic programming

Started with addition for some reason, TODO: repeat for multiplication
